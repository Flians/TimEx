unit TX_Globals;

{
    Unit TX_Globals (for use with TimEx)
    Copyright (c) 2016-2018 Coenrad Fourie

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
}

{$IFDEF Unix}
{$mode objfpc}{$H+}
{$ENDIF Unix}

interface

type
  {enumerated types, alphabetically}
  SourceTypeEnumerated = (Current,Voltage);
const
{$IFDEF MSWINDOWS}
  VersionNumber = '2.02.00';
{$ELSE}
  VersionNumber = '2.02.00 Linux 64-bit';
{$ENDIF}
  CopyRightNotice = 'Copyright 2016-2018 Coenrad Fourie, Stellenbosch University.';
  BuildDate = '10 Mar 2018';
  SpiceDeckLineLengthMax = 255;  // Maximum allowable characters in JSIM deck file lines. (Delphi dynamic arrays are prone to crashing if unlimited strings are used.)
  PHI_0 = 2.067833758e-15;
  EPSILON = 1e-20; // Arbitrary small number to test divide-by-zero occurrence

type
  Str1 = string[1]; // for layer filmtype characters
  Str40 = String[40];
  Str50 = String[50];
  Str88 = String[88];
  Str255 = String[255];
  StrSpiceLineMax = String[SpiceDeckLineLengthMax];
  {record types}

  DUTPortsRecord = record
    Name : Str40;
    Node : Str40;
    Number : Integer;
  end;
  ElementRecord = record
    Name : Str40;
    Value, Current : Double;
  end;
  TSpiceDeckLine = array of StrSpiceLineMax;
  DUTPortsArray = array of DUTPortsRecord;
  CycleListArray = array of array of Str40;
  ElementArray = array of ElementRecord;
  CycleFluxArray = array of Integer;
  InputTimesArray = array of array of Double;
  TInputResponseRecord = record
    toState : Integer;
    isValid : Boolean;
    outTimes : array of array of Double;  // Time to pulse at each output. Make time negative for no output
    criticalInTimes : array of array of Double; // Critical Timing value to every input pulse. Make negative for no critical relationship.
  end;
  TInputResponseArray = array of TInputResponseRecord;
  TStatesRecord = record
    time : Double;
    inputsToReach : InputTimesArray;
    cycleFlux : CycleFluxArray;
    inputResponse : TInputResponseArray;
  end;
  TStatesRecordArray = array of TStatesRecord;
  TLinesArray = array of Str255;
  TSweepRecord = record
    SweepVar : Str40;
    Start, Inc, Stop, Nominal : double;
    FunctionalAtStep : array of boolean;
  end;
  TSweep = array of TSweepRecord;
  TSpiceVariableRecord = record
    Name : str40;
    Value : double;
  end;
  TSpiceVariable = array of TSpiceVariableRecord;

var
  defFileParam, {loadFileParam,} loadInFileParam, loadOutFileParam, sinkFileParam, sourceFileParam, stateMapFileParam : Integer;
  outFile, spiceFile : TextFile;
  executeFile, engineName, dutCellName, cellNameStr, stateMapFileName : String;
  spiceDUTLines, spiceLoadInLines, spiceLoadOutLines, spiceSinkLines, spiceSourceLines : TSpiceDeckLine;
  dutInput, dutOutput : DUTPortsArray;
  cycleList : cycleListArray;
  elements, jjModels : ElementArray;
  sourceType : SourceTypeEnumerated;
  sourceAmplitude, sourceRiseTime, sourceFallTime, timeFirstStable, waitForStateChange, slidingIntegratorLength, pulseDetectThreshold : Double;
  ctDependencyThreshold, maxDelayChange, maxSelfDelayChange, verilogStableTime, verilogWaitTime, inputChainDelay, pulseFluxonFraction : Double;
  minSameInputSeparation, noiseTemp, simTimeStep : double;
  numSimsTol : integer;
  ioFullFluxon : boolean;
  cycleFlux : CycleFluxArray;
  inputTimes : InputTimesArray;
  states : TStatesRecordArray;
  lines : tLinesArray;
  runTB : boolean;       // If True, runs the testbench simulations
  verboseMode : boolean;
  sweeps : TSweep;
  spiceVariables : TSpiceVariable;
  sweepNominal : array of integer;
  applyRandom : boolean; // If false, gauss(mean, stddev) evaluates to (mean) - used for nominal analysis

implementation

end.

