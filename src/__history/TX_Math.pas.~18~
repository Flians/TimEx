unit TX_Math;

{
    Unit TX_Math (for use with TimEx)
    Copyright (c) 2016-2018 Coenrad Fourie

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
}

interface

uses
  SysUtils, Math, TX_Globals;
type
  DoubleArrayTipe = array of array of double;
  DoubleArraySingleTipe = array of double;

function CheckIfInteger(TestStr : string) : boolean;
function CheckIfReal(TestStr : string) : boolean;
procedure IntSwop(var int1, int2 : integer);
function ReturnLargest(Num1, Num2 : integer) : integer;
function EvaluateFunctionGauss(eStr : string) : double;


implementation

const
  MachineEpsilon = 5E-16;
  MaxRealNumber = 1E300;
  MinRealNumber = 1E-300;

{ ----------------------------- CheckIfInteger ------------------------------- }
function CheckIfInteger(TestStr : string) : boolean;

var
  c1 : integer;
  cb : boolean;

begin
  cb := true;
  if length(TestStr) = 1 then
    if not (ord(TestStr[1]) in [48..57]) then cb := false;
  if not ((TestStr[1] in ['+','-']) or (ord(TestStr[1]) in [48..57])) then
    cb := false;
  for c1 := 2 to length(TestStr) do
    if not (ord(TestStr[c1]) in [48..57]) then  // check if ordinal values of every character is in range 48 (0) to 57 (9)
      cb := false;
  CheckIfInteger := cb;
end; // CheckIfInteger
{ ------------------------------ CheckIfReal --------------------------------- }
function CheckIfReal(TestStr : string) : boolean;

var
  c1 : integer;
  cb, cexpfound, cpointfound, cesignfound, cefound : boolean;

begin
  cb := true; cexpfound := false; cpointfound := false; cefound := false;
  while copy(TestStr,1,1) = ' ' do
    delete(TestStr,1,1);                // strip leading spaces
  if TestStr = '' then // It's empty!
  begin
    CheckIfReal := False;
    Exit;
  end;
  while copy(TestStr,length(TestStr),1) = ' ' do
    delete(TestStr,length(TestStr),1);  // strip trailing spaces
  if length(TestStr) = 1 then
    if not (ord(TestStr[1]) in [48..57]) then cb := false;
  if not ( (ord(TestStr[1]) in [48..57]) or (TestStr[1] in ['-','+','.']) ) then
    cb := false;
  if  copy(TestStr,1,1) = '.' then
    cpointfound := true;
  for c1 := 2 to length(TestStr) do
  begin
    if (cpointfound or cefound) and (copy(TestStr,c1,1) = '.') then
      cb := false;
    if copy(TestStr,c1,1) = '.' then cpointfound := true;
    if (not cefound) and (TestStr[c1] in ['-','+']) then
      cb := false;
    if cefound and (ord(TestStr[c1]) in [48..57]) then
      cexpfound := true;
    if not ( (ord(TestStr[c1]) in [48..57]) or (TestStr[c1] in ['-','+','.','e','E']) ) then cb := false;
    if cefound and (TestStr[c1] in ['e','E']) then
      cb := false;
    if TestStr[c1] in ['e','E'] then
      cefound := true;
    if (cefound and cexpfound) and (TestStr[c1] in ['-','+']) then
      cb := false;
    if (cefound and (not cexpfound)) and (TestStr[c1] in ['-','+']) then
      cesignfound := true;
  end;
  CheckIfReal := cb;
end; // CheckIfReal
{ --------------------------------- IntSwop ---------------------------------- }
procedure IntSwop(var int1, int2 : integer);

var
  is1 : integer;

begin
  is1 := int1;
  int1 := int2;
  int2 := is1;
end; // IntSwop
{ ------------------------------ ReturnLargest ------------------------------- }
function ReturnLargest(Num1, Num2 : integer) : integer;

begin
  if Num1 > Num2 then
    ReturnLargest := Num1
  else ReturnLargest := Num2;
end;  // ReturnLargest
{ ------------------------- EvaluateFunctionGauss ---------------------------- }
function EvaluateFunctionGauss(eStr : string) : double;
// Returns value from gaussian distribution, found from eStr
var
  ef1, ef2 : double;
begin
  ef1 := 1;
  ef2 := 0;
  if CheckIfReal(copy(eStr, pos('(',eStr)+1, pos(',',eStr)-pos('(',eStr)-1)) then
    ef1 := StrToFloat(copy(eStr, pos('(',eStr)+1, pos(',',eStr)-pos('(',eStr)-1));
  if CheckIfReal(copy(eStr, pos(',',eStr)+1, pos(')',eStr)-pos(',',eStr)-1)) then
    ef2 := StrToFloat(copy(eStr, pos(',',eStr)+1, pos(')',eStr)-pos(',',eStr)-1));
end;


end.
